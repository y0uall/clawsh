// @name: kernel_exploit
// @description: Kernel version analysis, security features, and exploit suggestions
// @category: enumerate
// @target_os: linux
// @author: clawsh
// @version: 1.0

let output = "=== Kernel & Exploit Suggestions ===\n";

// --- Kernel info ---
let uname_r = exec_cmd("uname -r 2>/dev/null");
let uname_a = exec_cmd("uname -a 2>/dev/null");
let proc_version = exec_cmd("cat /proc/version 2>/dev/null");

output += "\n\x1b[1;4mKernel Information:\x1b[0m\n";
output += "  Kernel:  " + uname_r.trim() + "\n";
output += "  Full:    " + uname_a.trim() + "\n";
if proc_version.len() > 0 {
    output += "  Build:   " + proc_version.trim() + "\n";
}

// --- Architecture ---
let arch = exec_cmd("uname -m 2>/dev/null");
output += "  Arch:    " + arch.trim() + "\n";

// --- Distribution ---
let distro = exec_cmd("cat /etc/os-release 2>/dev/null | head -5");
if distro.len() > 0 {
    output += "\n\x1b[1;4mDistribution:\x1b[0m\n";
    for line in distro.split("\n") {
        if line.len() > 0 {
            output += "  " + line + "\n";
        }
    }
}

// --- glibc version ---
let glibc = exec_cmd("ldd --version 2>/dev/null | head -1");
output += "\n  glibc:   " + glibc.trim() + "\n";

// --- Security features ---
output += "\n\x1b[1;4mKernel Security Features:\x1b[0m\n";

let kptr = exec_cmd("cat /proc/sys/kernel/kptr_restrict 2>/dev/null");
if kptr.trim() == "0" {
    output += "  \x1b[33mkptr_restrict: 0 (kernel pointers exposed!)\x1b[0m\n";
} else {
    output += "  kptr_restrict: " + kptr.trim() + "\n";
}

let dmesg_restrict = exec_cmd("cat /proc/sys/kernel/dmesg_restrict 2>/dev/null");
if dmesg_restrict.trim() == "0" {
    output += "  \x1b[33mdmesg_restrict: 0 (dmesg readable by all)\x1b[0m\n";
} else {
    output += "  dmesg_restrict: " + dmesg_restrict.trim() + "\n";
}

let perf_paranoid = exec_cmd("cat /proc/sys/kernel/perf_event_paranoid 2>/dev/null");
output += "  perf_event_paranoid: " + perf_paranoid.trim() + "\n";

let randomize_va = exec_cmd("cat /proc/sys/kernel/randomize_va_space 2>/dev/null");
if randomize_va.trim() == "0" {
    output += "  \x1b[1;33mASLR: DISABLED!\x1b[0m\n";
} else if randomize_va.trim() == "1" {
    output += "  \x1b[33mASLR: partial (stack only)\x1b[0m\n";
} else {
    output += "  ASLR: " + randomize_va.trim() + " (full)\n";
}

// CPU security flags
let cpu_flags = exec_cmd("grep flags /proc/cpuinfo 2>/dev/null | head -1");
if cpu_flags.len() > 0 {
    let has_smep = cpu_flags.contains("smep");
    let has_smap = cpu_flags.contains("smap");
    let has_nx = cpu_flags.contains(" nx ");
    output += "  SMEP: " + if has_smep { "enabled" } else { "\x1b[33mNOT present\x1b[0m" } + "\n";
    output += "  SMAP: " + if has_smap { "enabled" } else { "\x1b[33mNOT present\x1b[0m" } + "\n";
    output += "  NX:   " + if has_nx { "enabled" } else { "\x1b[33mNOT present\x1b[0m" } + "\n";
}

// Secure boot
let secureboot = exec_cmd("mokutil --sb-state 2>/dev/null");
if secureboot.len() > 0 {
    output += "  Secure Boot: " + secureboot.trim() + "\n";
}

// --- Loaded kernel modules ---
output += "\n\x1b[1;4mLoaded Kernel Modules (interesting):\x1b[0m\n";
let lsmod_out = exec_cmd("lsmod 2>/dev/null");
let interesting_mods = [
    "nf_tables", "ip_tables", "overlay", "aufs",
    "vboxguest", "vmw_balloon", "hv_vmbus",
    "kvm", "xen",
    "fuse", "cifs", "nfs",
];

for mod_name in interesting_mods {
    if lsmod_out.contains(mod_name) {
        output += "  " + mod_name + "\n";
    }
}

// --- Exploit suggestions ---
output += "\n\x1b[1;4mKnown Exploit Suggestions:\x1b[0m\n";
let kernel = uname_r.trim();
let exploits_found = 0;

// Parse major.minor.patch from kernel version
// Format: 5.15.0-100-generic or 6.1.0
let version_parts = kernel.split(".");
let major = 0;
let minor = 0;
let patch = 0;

if version_parts.len() >= 1 {
    major = parse_int(version_parts[0]);
}
if version_parts.len() >= 2 {
    minor = parse_int(version_parts[1]);
}
if version_parts.len() >= 3 {
    // patch may be "0-100-generic", extract first number
    let patch_str = version_parts[2].split("-")[0];
    patch = parse_int(patch_str);
}

output += "  Kernel parsed: " + major.to_string() + "." + minor.to_string() + "." + patch.to_string() + "\n\n";

// DirtyPipe — CVE-2022-0847 (5.8 <= kernel < 5.16.11, 5.15.25, 5.10.102)
if major == 5 && ((minor >= 8 && minor < 16) || (minor == 16 && patch < 11)) {
    output += "  \x1b[1;31m[!] CVE-2022-0847 — DirtyPipe\x1b[0m\n";
    output += "      Kernel 5.8+ to 5.16.11 — arbitrary file overwrite via pipe splice\n";
    output += "      https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits\n";
    exploits_found += 1;
}

// DirtyCoW — CVE-2016-5195 (2.6.22 <= kernel <= 4.8.3)
if (major == 2 && minor == 6 && patch >= 22) || (major == 3) || (major == 4 && (minor < 8 || (minor == 8 && patch <= 3))) {
    output += "  \x1b[1;31m[!] CVE-2016-5195 — DirtyCow\x1b[0m\n";
    output += "      Kernel 2.6.22 to 4.8.3 — race condition in copy-on-write\n";
    exploits_found += 1;
}

// PwnKit — CVE-2021-4034 (any polkit, not kernel-specific)
let polkit = exec_cmd("pkexec --version 2>/dev/null");
if polkit.len() > 0 {
    output += "  \x1b[33m[?] CVE-2021-4034 — PwnKit (polkit " + polkit.trim() + ")\x1b[0m\n";
    output += "      Check if polkit version < 0.120\n";
    exploits_found += 1;
}

// GameOver(lay) — CVE-2023-2640 / CVE-2023-32629 (Ubuntu overlayfs)
if uname_a.contains("Ubuntu") && major >= 5 {
    output += "  \x1b[33m[?] CVE-2023-2640 / CVE-2023-32629 — GameOver(lay)\x1b[0m\n";
    output += "      Ubuntu-specific overlayfs privilege escalation\n";
    exploits_found += 1;
}

// Looney Tunables — CVE-2023-4911 (glibc 2.34-2.38)
if glibc.contains("2.34") || glibc.contains("2.35") || glibc.contains("2.36") || glibc.contains("2.37") || glibc.contains("2.38") {
    output += "  \x1b[1;31m[!] CVE-2023-4911 — Looney Tunables\x1b[0m\n";
    output += "      glibc 2.34-2.38 — buffer overflow in ld.so GLIBC_TUNABLES\n";
    exploits_found += 1;
}

// nf_tables — CVE-2023-32233
if lsmod_out.contains("nf_tables") && major == 5 && minor >= 1 {
    output += "  \x1b[33m[?] CVE-2023-32233 — nf_tables use-after-free\x1b[0m\n";
    output += "      Kernel 5.1+ with nf_tables loaded\n";
    exploits_found += 1;
}

// OverlayFS — CVE-2023-0386
if lsmod_out.contains("overlay") && major == 5 && minor >= 11 {
    output += "  \x1b[33m[?] CVE-2023-0386 — OverlayFS\x1b[0m\n";
    output += "      Kernel 5.11+ — fuse + overlayfs setuid bypass\n";
    exploits_found += 1;
}

// Netfilter — CVE-2022-25636
if major == 5 && minor >= 4 && minor <= 16 {
    output += "  \x1b[33m[?] CVE-2022-25636 — Netfilter heap overflow\x1b[0m\n";
    output += "      Kernel 5.4-5.16 — nf_dup_netdev.c\n";
    exploits_found += 1;
}

if exploits_found == 0 {
    output += "  (no known exploits matched — check manually)\n";
}

// --- Compiler / Dev tools ---
output += "\n\x1b[1;4mCompiler & Dev Tools:\x1b[0m\n";
let gcc_ver = exec_cmd("gcc --version 2>/dev/null | head -1");
let make_ver = exec_cmd("make --version 2>/dev/null | head -1");
let python_ver = exec_cmd("python3 --version 2>/dev/null");
let wget_ver = exec_cmd("which wget curl 2>/dev/null");

if gcc_ver.len() > 0 { output += "  \x1b[33mgcc: " + gcc_ver.trim() + "\x1b[0m\n"; }
if make_ver.len() > 0 { output += "  make: " + make_ver.trim() + "\n"; }
if python_ver.len() > 0 { output += "  python3: " + python_ver.trim() + "\n"; }
if wget_ver.len() > 0 { output += "  download: " + wget_ver.trim() + "\n"; }

if gcc_ver.len() > 0 {
    output += "  \x1b[33m(on-target compilation available)\x1b[0m\n";
}

print_output(output);

let RESULT = exploits_found.to_string() + " potential exploit(s) for kernel " + kernel;

let DATA = #{
    kernel: kernel,
    major: major,
    minor: minor,
    patch: patch,
    exploits_found: exploits_found,
    has_gcc: gcc_ver.len() > 0,
    aslr: randomize_va.trim(),
};
